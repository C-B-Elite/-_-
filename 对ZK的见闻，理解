# ZK理解

### 名称：

ZK-Snark：Zero-Knowledge Succinct Non-Interactive Argument of Knowledge，即零知识简洁非交互证明

### ZK介绍：

1. Q： 有三种主要的多项式承诺方案是目前广泛使用的：bulletproofs，Kate和FRI，bulletproofs，他们的区别和分别的独特特性，共同特性是什么？

    A：

    1. 共同点：
        1. Bulletproofs，Kate和FRI都是多项式承诺的主要类型。它们**共同的特点是用于在多项式中编码大量信息，并能在短时间内验证大型多项式之间的等式**。
    2. 区别：
        1. Bulletproofs: Bulletproofs的描述可以在curve25519-dalek团队的链接中找到。它们主要用于创建**短的**、**无信任设定**的**非交互式**零知识证明。
        2. Kate: 从**概念上讲，Kate是最简单的**，但**依赖于非常复杂的“黑箱”椭圆曲线配对**。您可以在Dankrad Feist的链接中找到关于Kate承诺的描述。
        3. FRI: FRI很酷，因为它**只依赖于散列**；它通过**逐步将一个多项式降低到一个更低和更低程度的多项式**，并**用Merkle分支进行随机样本检查以证明每个步骤的等价性**。对FRI的优化是当前正在研究的问题，包括精心选择的评估域，"DEEP-FRI"，以及许多其他技巧来提高FRI的效率。

1. Q： zksnarks是对计算的过程给出证明，但是不给出计算的结果对吗？

    A： 不完全是。**zk-SNARKs允许你生成一个证明，这个证明可以证明某个计算产生了特定的输出，但它并不透露输入的确切值**。这意味着你可以证明你已经做了一个复杂的计算，并获得了一个特定的结果，而不需要给出输入。**对于需要核实证明的人来说，他们可以迅速地核实该证明**，尽管底层计算可能需要很长时间。另外，**"零知识"部分意味着部分输入可被隐藏**。对于他们来说，**证明不会泄露隐藏的输入的具体数值**。


1. Q： 给出一个证明，这个证明可以 给验证者 验证 给出证明的人 已经执行了全部计算，并且证明者给出的结果即是证明者给出的Proof所证明的计算过程，对吗？【即Proof可以证明：prover已经合法地计算了需要进行的计算，并产生了合法的结果】

    A： 对的，人们可以产生一个证明，表示已经完成了某种特定的计算，并得到了特定的结果。

     即Proof可以证明计算过程的合法性以及结果的合法性


1. Q： zksnarks可以不透露全部的输入，但是需要透露部分输入吗？还是可以完全不透露任何输入？

    A： zk-SNARKs可以透露一部分输入，也可以完全不透露任何输入信息；**具体透露什么以及是否透露可以自由选择（完全不透露的特性即零知识）**。如果用户愿意，也可以选择透露一部分输入信息。这完全取决于应用和用户的需求。

    1. zk-SNARKs ("零知识简洁知识论证")允许你生成一个证明，表明某个计算具有特定的输出，且该证明可以非常快速地被验证，即使底层的计算需要很长时间来运行。其"ZK"（"零知识"）部分增加了一个附加特性：证明可以保持计算输入的一部分隐藏。这意味着在使用zk-SNARKs时，你并不需要透露所有的输入。
    2. 目前已有许多不同的零知识证明算法，包括zk-SNARKs, zk-STARKs, Bulletproofs等，其中许多算法在设计中都考虑了保护输入信息的问题，例如Bulletproofs算法，也不需要透露输入的全部信息。所以确实存在其他算法可以在不透露部分输入的情况下进行运算。
    3. 在使用zk-SNARKs或其他零知识证明算法时，你可以选择性的隐藏计算的一部分输入。例如，你可以制作一个证明来声明：“我知道一个秘密数字，如果你拿'牛'这个词，把这个数字加在末尾，并进行一亿次SHA256散列，输出以0x57d00485aa开始。”这将不会透露这个秘密数字是什么，并且，验证者可以远比他们自己运行一亿次散列更快地验证该证明。对于区块链，这样可以在保证资产转移的安全性（你确实收到了这个资产并且你还没转让它）的同时，又不会透露你收到了哪个资产，这有效地防止了公众获取到与谁和谁进行交易的信息。

1. Q：所以zksnarks的核心在于：validator不需要执行全部的计算过程，而是随机选择了其中部分计算过程，并通过这些计算过程验证给出proof的prover的结果，对吗？

    A： zk-SNARKs的**核心并不完全是随机选择一部分计算进行验证，而是将整个计算编码成多项式**。然后**通过验证多项式是否满足某些属性，从而验证整个计算过程的正确性**。 这样就可以在不需要逐一检查每个计算步骤的情况下验证整个计算。


1. Q：验证着如何在完全不知道输入的情况下验证计算结果的合法性？

    A：校验者可以通过一种称为**随机抽样的技术来验证计算结果的真实性**，而**不需要完全知道输入**。他们可以在**计算中的500个不同位置偷窥**，检查这些部分是否正确，**如果所有500个检查都通过了，那么可以假设整个计算的其他部分也很有可能是正确的【核心依据，信任终点】**。这个过程甚至可以使用Fiat-Shamir启发式方法转化为非交互式证明：证明者计算出计算的默克尔根，使用默克尔根伪随机地选择500个索引，并提供数据的500个对应默克尔分支。关键的想法是证明者在已经“承诺”数据之后，不知道哪些分支需要揭示。如果一个恶意的证明者试图在知道要检查的索引之后篡改数据，那将改变默克尔根，结果将产生一组新的随机索引，这将需要再次篡改数据...把恶意的证明者陷入一个无尽的循环中。


### 总结：

1. ZK的核心即： 在prover（proof给出者）和validator（proof验证者），以及一笔Tx的场景下，validator可以在不知道Tx输入的情况下，通过验证prover给出的proof的合法性，确信prover给出的Tx Output为合法的。从而使Validator不需要知道，执行Tx的输入以及变化过程（Function），即可对Tx的Output进行可信共识。即将智能合约外包，并且可以让区块链信任。
2. 信任转嫁： 将区块链大多数节点执行并对结果共识（最长链/签名）的信任转嫁为对ZK Proof验证的信任。即将对大多数人的信任转嫁为对密码学的绝对可信性的信任 ⇒ 共识从对“大多数人” 转嫁为对“执行结果的共识（密码学Proof）”
3. 区块链思考框架：
    1. 信任转嫁，谁是信任终点
    2. 哪些人【链的参与方（都有哪些方，矿工群体之类的）】 通过 哪个方式【共识算法】 对 什么东西【链上数据（Proof（比如RollUp）还是明文数据（比如直接转账的Tx数据））】 以 什么条件【共识数据的最终一致性确认】 在 什么情况下【达成最终一致性的依据（比如最长链）】 达成了共识

### 资料：

vitalik 介绍zk：

[https://vitalik.eth.limo/general/2021/01/26/snarks.html](https://vitalik.eth.limo/general/2021/01/26/snarks.html)
